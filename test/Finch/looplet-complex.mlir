// RUN: finch-opt %s --finch-looplet-pass | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

func.func private @linearsearch(%pos: index, %idx : index, %ptr : memref<?xindex>, %crd : memref<?xindex>) -> index 

// CHECK-LABEL:   func.func @test1(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 2.000000e+00 : f32
// CHECK:           %[[VAL_3:.*]] = arith.constant -0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_6:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_7:.*]] = memref.alloc(%[[VAL_6]]) : memref<?xindex>
// CHECK:           %[[VAL_8:.*]] = memref.alloc(%[[VAL_6]]) : memref<?xindex>
// CHECK:           %[[VAL_9:.*]] = memref.load %[[VAL_7]]{{\[}}%[[VAL_6]]] : memref<?xindex>
// CHECK:           %[[VAL_10:.*]] = memref.load %[[VAL_7]]{{\[}}%[[VAL_5]]] : memref<?xindex>
// CHECK:           %[[VAL_11:.*]] = arith.cmpi eq, %[[VAL_10]], %[[VAL_9]] : index
// CHECK:           %[[VAL_12:.*]] = scf.if %[[VAL_11]] -> (index) {
// CHECK:             scf.yield %[[VAL_5]] : index
// CHECK:           } else {
// CHECK:             %[[VAL_13:.*]] = arith.subi %[[VAL_9]], %[[VAL_6]] : index
// CHECK:             %[[VAL_14:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_13]]] : memref<?xindex>
// CHECK:             %[[VAL_15:.*]] = arith.addi %[[VAL_14]], %[[VAL_6]] : index
// CHECK:             scf.yield %[[VAL_15]] : index
// CHECK:           }
// CHECK:           %[[VAL_16:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_16]][] : memref<f32>
// CHECK:           %[[VAL_17:.*]] = arith.minui %[[VAL_1]], %[[VAL_12]] : index
// CHECK:           %[[VAL_18:.*]] = arith.maxui %[[VAL_0]], %[[VAL_12]] : index
// CHECK:           %[[VAL_19:.*]] = arith.minui %[[VAL_17]], %[[VAL_12]] : index
// CHECK:           %[[VAL_20:.*]] = arith.maxui %[[VAL_0]], %[[VAL_12]] : index
// CHECK:           %[[VAL_21:.*]] = call @linearsearch(%[[VAL_5]], %[[VAL_0]], %[[VAL_7]], %[[VAL_8]]) : (index, index, memref<?xindex>, memref<?xindex>) -> index
// CHECK:           %[[VAL_22:.*]] = call @linearsearch(%[[VAL_5]], %[[VAL_0]], %[[VAL_7]], %[[VAL_8]]) : (index, index, memref<?xindex>, memref<?xindex>) -> index
// CHECK:           %[[VAL_23:.*]]:3 = scf.while (%[[VAL_24:.*]] = %[[VAL_21]], %[[VAL_25:.*]] = %[[VAL_22]], %[[VAL_26:.*]] = %[[VAL_0]]) : (index, index, index) -> (index, index, index) {
// CHECK:             %[[VAL_27:.*]] = arith.cmpi ult, %[[VAL_26]], %[[VAL_19]] : index
// CHECK:             scf.condition(%[[VAL_27]]) %[[VAL_24]], %[[VAL_25]], %[[VAL_26]] : index, index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_28:.*]]: index, %[[VAL_29:.*]]: index, %[[VAL_30:.*]]: index):
// CHECK:             %[[VAL_31:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_28]]] : memref<?xindex>
// CHECK:             %[[VAL_32:.*]] = arith.addi %[[VAL_31]], %[[VAL_6]] : index
// CHECK:             %[[VAL_33:.*]] = arith.minui %[[VAL_19]], %[[VAL_32]] : index
// CHECK:             %[[VAL_34:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_29]]] : memref<?xindex>
// CHECK:             %[[VAL_35:.*]] = arith.addi %[[VAL_34]], %[[VAL_6]] : index
// CHECK:             %[[VAL_36:.*]] = arith.minui %[[VAL_33]], %[[VAL_35]] : index
// CHECK:             %[[VAL_37:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_28]]] : memref<?xindex>
// CHECK:             %[[VAL_38:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_29]]] : memref<?xindex>
// CHECK:             %[[VAL_39:.*]] = arith.minui %[[VAL_36]], %[[VAL_37]] : index
// CHECK:             %[[VAL_40:.*]] = arith.maxui %[[VAL_30]], %[[VAL_37]] : index
// CHECK:             %[[VAL_41:.*]] = arith.minui %[[VAL_39]], %[[VAL_38]] : index
// CHECK:             %[[VAL_42:.*]] = arith.maxui %[[VAL_30]], %[[VAL_38]] : index
// CHECK:             scf.for %[[VAL_43:.*]] = %[[VAL_30]] to %[[VAL_41]] step %[[VAL_6]] {
// CHECK:               %[[VAL_44:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               memref.store %[[VAL_44]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             scf.for %[[VAL_45:.*]] = %[[VAL_42]] to %[[VAL_39]] step %[[VAL_6]] {
// CHECK:               %[[VAL_46:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               %[[VAL_47:.*]] = arith.addf %[[VAL_46]], %[[VAL_4]] : f32
// CHECK:               memref.store %[[VAL_47]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_48:.*]] = arith.minui %[[VAL_36]], %[[VAL_38]] : index
// CHECK:             %[[VAL_49:.*]] = arith.maxui %[[VAL_40]], %[[VAL_38]] : index
// CHECK:             scf.for %[[VAL_50:.*]] = %[[VAL_40]] to %[[VAL_48]] step %[[VAL_6]] {
// CHECK:               %[[VAL_51:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               %[[VAL_52:.*]] = arith.addf %[[VAL_51]], %[[VAL_4]] : f32
// CHECK:               memref.store %[[VAL_52]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             scf.for %[[VAL_53:.*]] = %[[VAL_49]] to %[[VAL_36]] step %[[VAL_6]] {
// CHECK:               %[[VAL_54:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               %[[VAL_55:.*]] = arith.addf %[[VAL_54]], %[[VAL_2]] : f32
// CHECK:               memref.store %[[VAL_55]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_56:.*]] = arith.cmpi eq, %[[VAL_32]], %[[VAL_36]] : index
// CHECK:             %[[VAL_57:.*]] = scf.if %[[VAL_56]] -> (index) {
// CHECK:               %[[VAL_58:.*]] = arith.addi %[[VAL_28]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_58]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_28]] : index
// CHECK:             }
// CHECK:             %[[VAL_59:.*]] = arith.cmpi eq, %[[VAL_35]], %[[VAL_36]] : index
// CHECK:             %[[VAL_60:.*]] = scf.if %[[VAL_59]] -> (index) {
// CHECK:               %[[VAL_61:.*]] = arith.addi %[[VAL_29]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_61]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_29]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_57]], %[[VAL_60]], %[[VAL_36]] : index, index, index
// CHECK:           }
// CHECK:           %[[VAL_62:.*]] = call @linearsearch(%[[VAL_5]], %[[VAL_20]], %[[VAL_7]], %[[VAL_8]]) : (index, index, memref<?xindex>, memref<?xindex>) -> index
// CHECK:           %[[VAL_63:.*]]:2 = scf.while (%[[VAL_64:.*]] = %[[VAL_62]], %[[VAL_65:.*]] = %[[VAL_20]]) : (index, index) -> (index, index) {
// CHECK:             %[[VAL_66:.*]] = arith.cmpi ult, %[[VAL_65]], %[[VAL_17]] : index
// CHECK:             scf.condition(%[[VAL_66]]) %[[VAL_64]], %[[VAL_65]] : index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_67:.*]]: index, %[[VAL_68:.*]]: index):
// CHECK:             %[[VAL_69:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_67]]] : memref<?xindex>
// CHECK:             %[[VAL_70:.*]] = arith.addi %[[VAL_69]], %[[VAL_6]] : index
// CHECK:             %[[VAL_71:.*]] = arith.minui %[[VAL_17]], %[[VAL_70]] : index
// CHECK:             %[[VAL_72:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_67]]] : memref<?xindex>
// CHECK:             %[[VAL_73:.*]] = arith.minui %[[VAL_71]], %[[VAL_72]] : index
// CHECK:             %[[VAL_74:.*]] = arith.maxui %[[VAL_68]], %[[VAL_72]] : index
// CHECK:             scf.for %[[VAL_75:.*]] = %[[VAL_68]] to %[[VAL_73]] step %[[VAL_6]] {
// CHECK:               %[[VAL_76:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               memref.store %[[VAL_76]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             scf.for %[[VAL_77:.*]] = %[[VAL_74]] to %[[VAL_71]] step %[[VAL_6]] {
// CHECK:               %[[VAL_78:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               %[[VAL_79:.*]] = arith.addf %[[VAL_78]], %[[VAL_4]] : f32
// CHECK:               memref.store %[[VAL_79]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_80:.*]] = arith.cmpi eq, %[[VAL_70]], %[[VAL_71]] : index
// CHECK:             %[[VAL_81:.*]] = scf.if %[[VAL_80]] -> (index) {
// CHECK:               %[[VAL_82:.*]] = arith.addi %[[VAL_67]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_82]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_67]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_81]], %[[VAL_71]] : index, index
// CHECK:           }
// CHECK:           %[[VAL_83:.*]] = arith.minui %[[VAL_1]], %[[VAL_12]] : index
// CHECK:           %[[VAL_84:.*]] = arith.maxui %[[VAL_18]], %[[VAL_12]] : index
// CHECK:           %[[VAL_85:.*]] = call @linearsearch(%[[VAL_5]], %[[VAL_18]], %[[VAL_7]], %[[VAL_8]]) : (index, index, memref<?xindex>, memref<?xindex>) -> index
// CHECK:           %[[VAL_86:.*]]:2 = scf.while (%[[VAL_87:.*]] = %[[VAL_85]], %[[VAL_88:.*]] = %[[VAL_18]]) : (index, index) -> (index, index) {
// CHECK:             %[[VAL_89:.*]] = arith.cmpi ult, %[[VAL_88]], %[[VAL_83]] : index
// CHECK:             scf.condition(%[[VAL_89]]) %[[VAL_87]], %[[VAL_88]] : index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_90:.*]]: index, %[[VAL_91:.*]]: index):
// CHECK:             %[[VAL_92:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_90]]] : memref<?xindex>
// CHECK:             %[[VAL_93:.*]] = arith.addi %[[VAL_92]], %[[VAL_6]] : index
// CHECK:             %[[VAL_94:.*]] = arith.minui %[[VAL_83]], %[[VAL_93]] : index
// CHECK:             %[[VAL_95:.*]] = memref.load %[[VAL_8]]{{\[}}%[[VAL_90]]] : memref<?xindex>
// CHECK:             %[[VAL_96:.*]] = arith.minui %[[VAL_94]], %[[VAL_95]] : index
// CHECK:             %[[VAL_97:.*]] = arith.maxui %[[VAL_91]], %[[VAL_95]] : index
// CHECK:             scf.for %[[VAL_98:.*]] = %[[VAL_91]] to %[[VAL_96]] step %[[VAL_6]] {
// CHECK:               %[[VAL_99:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               memref.store %[[VAL_99]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             scf.for %[[VAL_100:.*]] = %[[VAL_97]] to %[[VAL_94]] step %[[VAL_6]] {
// CHECK:               %[[VAL_101:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:               %[[VAL_102:.*]] = arith.addf %[[VAL_101]], %[[VAL_4]] : f32
// CHECK:               memref.store %[[VAL_102]], %[[VAL_16]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_103:.*]] = arith.cmpi eq, %[[VAL_93]], %[[VAL_94]] : index
// CHECK:             %[[VAL_104:.*]] = scf.if %[[VAL_103]] -> (index) {
// CHECK:               %[[VAL_105:.*]] = arith.addi %[[VAL_90]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_105]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_90]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_104]], %[[VAL_94]] : index, index
// CHECK:           }
// CHECK:           scf.for %[[VAL_106:.*]] = %[[VAL_84]] to %[[VAL_1]] step %[[VAL_6]] {
// CHECK:             %[[VAL_107:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:             memref.store %[[VAL_107]], %[[VAL_16]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_108:.*]] = memref.load %[[VAL_16]][] : memref<f32>
// CHECK:           return %[[VAL_108]] : f32
// CHECK:         }
func.func @test1(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant -0.0 : f32
  %f1 = arith.constant 1.0 : f32
  %pos = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %ptr = memref.alloc(%c1) : memref<?xindex>
  %crd = memref.alloc(%c1) : memref<?xindex>

  %l0 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = func.call @linearsearch(%pos, %idx, %ptr, %crd) : (index, index, memref<?xindex>, memref<?xindex>) -> (index)
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos1 : index):
          %currcrd = memref.load %crd[%pos1] : memref<?xindex>
          %stopub = arith.addi %currcrd, %c1 : index
          finch.return %stopub : index
      }
      body={
        ^bb(%pos1 : index):
          %currcrd = memref.load %crd[%pos1] : memref<?xindex>

          %zero_run = finch.run %f0 : (f32) -> (!finch.looplet)
          %nonzero_run = finch.run %f1 : (f32) -> (!finch.looplet)
          %seq = finch.sequence %currcrd, %zero_run, %nonzero_run : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)
          finch.return %seq : !finch.looplet
      }
      next={
        ^bb0(%pos1 : index):
          %nextpos = arith.addi %pos1, %c1 : index
          finch.return %nextpos : index
      }

  %nextpos = arith.addi %pos, %c1 : index
  %nextoffset = memref.load %ptr[%nextpos] : memref<?xindex>
  %curroffset = memref.load %ptr[%pos] : memref<?xindex>
  %empty = arith.cmpi eq, %curroffset, %nextoffset : index
  %zero_ub = scf.if %empty -> (index) {
    %c0 = arith.constant 0 : index
    scf.yield %c0 : index
  } else {
    %lastoffset = arith.subi %nextoffset, %c1 : index
    %last_nnz_crd = memref.load %crd[%lastoffset] : memref<?xindex>
    %last_nnz_ub = arith.addi %last_nnz_crd, %c1 : index
    scf.yield %last_nnz_ub : index
  }

  %zero_run = finch.run %f0 : (f32) -> (!finch.looplet)
  %seq = finch.sequence %zero_ub, %l0, %zero_run : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurlseq1 = finch.access %seq, %i : f32
    %unfurlseq2 = finch.access %seq, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.addf %unfurlseq1, %unfurlseq2 : f32
    %added = arith.addf %mul, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}

