// RUN: finch-opt %s --finch-looplet-lookup | FileCheck %s 

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL:   func.func @test1(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_3:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf32>
// CHECK:           %[[VAL_5:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_2]], %[[VAL_5]][] : memref<f32>
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_0]] to %[[VAL_1]] step %[[VAL_3]] {
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_4]]{{\[}}%[[VAL_6]]] : memref<?xf32>
// CHECK:             %[[VAL_8:.*]] = finch.run %[[VAL_7]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_9:.*]] = finch.access %[[VAL_8]], %[[VAL_6]] : f32
// CHECK:             %[[VAL_10:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:             %[[VAL_11:.*]] = arith.addf %[[VAL_9]], %[[VAL_10]] : f32
// CHECK:             memref.store %[[VAL_11]], %[[VAL_5]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_12:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:           return %[[VAL_12]] : f32
// CHECK:         }
func.func @test1(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant 0.0 : f32
  %c1 = arith.constant 1 : index
  %vals = memref.alloc(%c1) : memref<?xf32>

  %lookup = finch.lookup
    body = {
      ^bb(%idx : index) :
        %val = memref.load %vals[%idx] : memref<?xf32>
        %run = finch.run %val : (f32) -> (!finch.looplet)
        finch.return %run : !finch.looplet
    }

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurl = finch.access %lookup, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %added = arith.addf %unfurl, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}


// CHECK-LABEL:   func.func @test2(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_3:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf32>
// CHECK:           %[[VAL_5:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf32>
// CHECK:           %[[VAL_6:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_2]], %[[VAL_6]][] : memref<f32>
// CHECK:           scf.for %[[VAL_7:.*]] = %[[VAL_0]] to %[[VAL_1]] step %[[VAL_3]] {
// CHECK:             %[[VAL_8:.*]] = memref.load %[[VAL_4]]{{\[}}%[[VAL_7]]] : memref<?xf32>
// CHECK:             %[[VAL_9:.*]] = finch.run %[[VAL_8]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_10:.*]] = finch.access %[[VAL_9]], %[[VAL_7]] : f32
// CHECK:             %[[VAL_11:.*]] = memref.load %[[VAL_5]]{{\[}}%[[VAL_7]]] : memref<?xf32>
// CHECK:             %[[VAL_12:.*]] = finch.run %[[VAL_11]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_13:.*]] = finch.access %[[VAL_12]], %[[VAL_7]] : f32
// CHECK:             %[[VAL_14:.*]] = memref.load %[[VAL_6]][] : memref<f32>
// CHECK:             %[[VAL_15:.*]] = arith.mulf %[[VAL_10]], %[[VAL_13]] : f32
// CHECK:             %[[VAL_16:.*]] = arith.addf %[[VAL_15]], %[[VAL_14]] : f32
// CHECK:             memref.store %[[VAL_16]], %[[VAL_6]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_17:.*]] = memref.load %[[VAL_6]][] : memref<f32>
// CHECK:           return %[[VAL_17]] : f32
// CHECK:         }
func.func @test2(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant 0.0 : f32
  %c1 = arith.constant 1 : index

  %vals1 = memref.alloc(%c1) : memref<?xf32>
  %vals2 = memref.alloc(%c1) : memref<?xf32>

  %lookup1 = finch.lookup
    body = {
      ^bb(%idx : index) :
        %val = memref.load %vals1[%idx] : memref<?xf32>
        %run = finch.run %val : (f32) -> (!finch.looplet)
        finch.return %run : !finch.looplet
    }
  %lookup2 = finch.lookup
    body = {
      ^bb(%idx : index) :
        %val = memref.load %vals2[%idx] : memref<?xf32>
        %run = finch.run %val : (f32) -> (!finch.looplet)
        finch.return %run : !finch.looplet
    }


  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurl1 = finch.access %lookup1, %i : f32
    %unfurl2 = finch.access %lookup2, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.mulf %unfurl1, %unfurl2 : f32
    %added = arith.addf %mul, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}
