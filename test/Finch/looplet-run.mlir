// RUN: finch-opt %s --finch-looplet-run | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.
// CHECK-LABEL:   func.func @test1(
// CHECK-SAME:                    %[[VAL_0:.*]]: index,
// CHECK-SAME:                    %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 2.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_5]][] : memref<f32>
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_0]] to %[[VAL_1]] step %[[VAL_2]] {
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:             %[[VAL_8:.*]] = arith.addf %[[VAL_7]], %[[VAL_4]] : f32
// CHECK:             memref.store %[[VAL_8]], %[[VAL_5]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_9:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:           return %[[VAL_9]] : f32
// CHECK:         }
func.func @test1(%b0:index, %b1:index) -> f32{
  %1 = arith.constant 1 : index
  %2 = arith.constant 0.0 : f32
  %3 = arith.constant 2.0 : f32
  %4 = finch.run %3 : (f32) -> (!finch.looplet)

  %5 = memref.alloc() : memref<f32>
  memref.store %2, %5[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %1 {
    %6 = finch.access %4, %i : f32
    %7 = memref.load %5[] : memref<f32>
    %8 = arith.addf %6, %7 : f32
    memref.store %8, %5[] : memref<f32>
  }
  
  %9 = memref.load %5[] : memref<f32>
  return %9 : f32
}

// CHECK-LABEL:   func.func @test2(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 8.000000e+00 : f32
// CHECK:           %[[VAL_3:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_4:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_4]], %[[VAL_5]][] : memref<f32>
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_0]] to %[[VAL_1]] step %[[VAL_3]] {
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:             %[[VAL_8:.*]] = arith.addf %[[VAL_7]], %[[VAL_2]] : f32
// CHECK:             memref.store %[[VAL_8]], %[[VAL_5]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_9:.*]] = memref.load %[[VAL_5]][] : memref<f32>
// CHECK:           return %[[VAL_9]] : f32
// CHECK:         }
func.func @test2(%b0:index, %b1:index) -> f32{
  %i1 = arith.constant 1 : index
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 2.0 : f32
  
  %run1 = finch.run %f1 : (f32) -> (!finch.looplet)
  %run2 = finch.run %f2 : (f32) -> (!finch.looplet)

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %i1 {
    %runvalue1 = finch.access %run1, %i : f32
    %runvalue2 = finch.access %run2, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mulv1v2 = arith.mulf %runvalue1, %runvalue2 : f32
    %added = arith.addf %mulv1v2, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}
