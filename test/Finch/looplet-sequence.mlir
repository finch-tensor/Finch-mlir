// RUN: finch-opt %s --finch-looplet-sequence | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.


// CHECK-LABEL:   func.func @singlesequence(
// CHECK-SAME:                              %[[VAL_0:.*]]: index,
// CHECK-SAME:                              %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 2.000000e+00 : f32
// CHECK:           %[[VAL_6:.*]] = arith.constant 3 : index
// CHECK:           %[[VAL_7:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_8:.*]] = finch.run %[[VAL_5]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_9:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_9]][] : memref<f32>
// CHECK:           %[[VAL_10:.*]] = arith.minui %[[VAL_1]], %[[VAL_6]] : index
// CHECK:           %[[VAL_11:.*]] = arith.maxui %[[VAL_0]], %[[VAL_6]] : index
// CHECK:           scf.for %[[VAL_12:.*]] = %[[VAL_0]] to %[[VAL_10]] step %[[VAL_2]] {
// CHECK:             %[[VAL_13:.*]] = finch.access %[[VAL_7]], %[[VAL_12]] : f32
// CHECK:             %[[VAL_14:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:             %[[VAL_15:.*]] = arith.addf %[[VAL_13]], %[[VAL_14]] : f32
// CHECK:             memref.store %[[VAL_15]], %[[VAL_9]][] : memref<f32>
// CHECK:           }
// CHECK:           scf.for %[[VAL_16:.*]] = %[[VAL_11]] to %[[VAL_1]] step %[[VAL_2]] {
// CHECK:             %[[VAL_17:.*]] = finch.access %[[VAL_8]], %[[VAL_16]] : f32
// CHECK:             %[[VAL_18:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:             %[[VAL_19:.*]] = arith.addf %[[VAL_17]], %[[VAL_18]] : f32
// CHECK:             memref.store %[[VAL_19]], %[[VAL_9]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_20:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:           return %[[VAL_20]] : f32
// CHECK:         }
func.func @singlesequence(%b0:index, %b1:index) -> f32{
  %i1 = arith.constant 1 : index
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 2.0 : f32
  %second_start = arith.constant 3 : index

  %run1 = finch.run %f1 : (f32) -> (!finch.looplet)
  %run2 = finch.run %f2 : (f32) -> (!finch.looplet)
  %seq1 = finch.sequence %second_start, %run1, %run2 : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %i1 {
    %unfurlseq = finch.access %seq1, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %added = arith.addf %unfurlseq, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}


// CHECK-LABEL:   func.func @doublesequence(
// CHECK-SAME:                              %[[VAL_0:.*]]: index,
// CHECK-SAME:                              %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 2.000000e+00 : f32
// CHECK:           %[[VAL_6:.*]] = arith.constant 3 : index
// CHECK:           %[[VAL_7:.*]] = arith.constant 6 : index
// CHECK:           %[[VAL_8:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_9:.*]] = finch.run %[[VAL_5]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_10:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_10]][] : memref<f32>
// CHECK:           %[[VAL_11:.*]] = arith.minui %[[VAL_1]], %[[VAL_6]] : index
// CHECK:           %[[VAL_12:.*]] = arith.maxui %[[VAL_0]], %[[VAL_6]] : index
// CHECK:           %[[VAL_13:.*]] = arith.minui %[[VAL_11]], %[[VAL_7]] : index
// CHECK:           %[[VAL_14:.*]] = arith.maxui %[[VAL_0]], %[[VAL_7]] : index
// CHECK:           scf.for %[[VAL_15:.*]] = %[[VAL_0]] to %[[VAL_13]] step %[[VAL_2]] {
// CHECK:             %[[VAL_16:.*]] = finch.access %[[VAL_8]], %[[VAL_15]] : f32
// CHECK:             %[[VAL_17:.*]] = finch.access %[[VAL_8]], %[[VAL_15]] : f32
// CHECK:             %[[VAL_18:.*]] = memref.load %[[VAL_10]][] : memref<f32>
// CHECK:             %[[VAL_19:.*]] = arith.mulf %[[VAL_16]], %[[VAL_17]] : f32
// CHECK:             %[[VAL_20:.*]] = arith.addf %[[VAL_19]], %[[VAL_18]] : f32
// CHECK:             memref.store %[[VAL_20]], %[[VAL_10]][] : memref<f32>
// CHECK:           }
// CHECK:           scf.for %[[VAL_21:.*]] = %[[VAL_14]] to %[[VAL_11]] step %[[VAL_2]] {
// CHECK:             %[[VAL_22:.*]] = finch.access %[[VAL_8]], %[[VAL_21]] : f32
// CHECK:             %[[VAL_23:.*]] = finch.access %[[VAL_9]], %[[VAL_21]] : f32
// CHECK:             %[[VAL_24:.*]] = memref.load %[[VAL_10]][] : memref<f32>
// CHECK:             %[[VAL_25:.*]] = arith.mulf %[[VAL_22]], %[[VAL_23]] : f32
// CHECK:             %[[VAL_26:.*]] = arith.addf %[[VAL_25]], %[[VAL_24]] : f32
// CHECK:             memref.store %[[VAL_26]], %[[VAL_10]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_27:.*]] = arith.minui %[[VAL_1]], %[[VAL_7]] : index
// CHECK:           %[[VAL_28:.*]] = arith.maxui %[[VAL_12]], %[[VAL_7]] : index
// CHECK:           scf.for %[[VAL_29:.*]] = %[[VAL_12]] to %[[VAL_27]] step %[[VAL_2]] {
// CHECK:             %[[VAL_30:.*]] = finch.access %[[VAL_9]], %[[VAL_29]] : f32
// CHECK:             %[[VAL_31:.*]] = finch.access %[[VAL_8]], %[[VAL_29]] : f32
// CHECK:             %[[VAL_32:.*]] = memref.load %[[VAL_10]][] : memref<f32>
// CHECK:             %[[VAL_33:.*]] = arith.mulf %[[VAL_30]], %[[VAL_31]] : f32
// CHECK:             %[[VAL_34:.*]] = arith.addf %[[VAL_33]], %[[VAL_32]] : f32
// CHECK:             memref.store %[[VAL_34]], %[[VAL_10]][] : memref<f32>
// CHECK:           }
// CHECK:           scf.for %[[VAL_35:.*]] = %[[VAL_28]] to %[[VAL_1]] step %[[VAL_2]] {
// CHECK:             %[[VAL_36:.*]] = finch.access %[[VAL_9]], %[[VAL_35]] : f32
// CHECK:             %[[VAL_37:.*]] = finch.access %[[VAL_9]], %[[VAL_35]] : f32
// CHECK:             %[[VAL_38:.*]] = memref.load %[[VAL_10]][] : memref<f32>
// CHECK:             %[[VAL_39:.*]] = arith.mulf %[[VAL_36]], %[[VAL_37]] : f32
// CHECK:             %[[VAL_40:.*]] = arith.addf %[[VAL_39]], %[[VAL_38]] : f32
// CHECK:             memref.store %[[VAL_40]], %[[VAL_10]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_41:.*]] = memref.load %[[VAL_10]][] : memref<f32>
// CHECK:           return %[[VAL_41]] : f32
// CHECK:         }
func.func @doublesequence(%b0:index, %b1:index) -> f32{
  %i1 = arith.constant 1 : index
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 2.0 : f32
  %second_start1 = arith.constant 3 : index
  %second_start2 = arith.constant 6 : index

  %run1 = finch.run %f1 : (f32) -> (!finch.looplet)
  %run2 = finch.run %f2 : (f32) -> (!finch.looplet)
  %seq1 = finch.sequence %second_start1, %run1, %run2 : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)
  %seq2 = finch.sequence %second_start2, %run1, %run2 : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %i1 {
    %unfurlseq1 = finch.access %seq1, %i : f32
    %unfurlseq2 = finch.access %seq2, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.mulf %unfurlseq1, %unfurlseq2 : f32
    %added = arith.addf %mul, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}


// CHECK-LABEL:   func.func @runsequence(
// CHECK-SAME:                           %[[VAL_0:.*]]: index,
// CHECK-SAME:                           %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 2.000000e+00 : f32
// CHECK:           %[[VAL_6:.*]] = arith.constant 3 : index
// CHECK:           %[[VAL_7:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_8:.*]] = finch.run %[[VAL_5]] : (f32) -> (!finch.looplet)
// CHECK:           %[[VAL_9:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_9]][] : memref<f32>
// CHECK:           %[[VAL_10:.*]] = arith.minui %[[VAL_1]], %[[VAL_6]] : index
// CHECK:           %[[VAL_11:.*]] = arith.maxui %[[VAL_0]], %[[VAL_6]] : index
// CHECK:           scf.for %[[VAL_12:.*]] = %[[VAL_0]] to %[[VAL_10]] step %[[VAL_2]] {
// CHECK:             %[[VAL_13:.*]] = finch.access %[[VAL_7]], %[[VAL_12]] : f32
// CHECK:             %[[VAL_14:.*]] = finch.access %[[VAL_8]], %[[VAL_12]] : f32
// CHECK:             %[[VAL_15:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:             %[[VAL_16:.*]] = arith.mulf %[[VAL_13]], %[[VAL_14]] : f32
// CHECK:             %[[VAL_17:.*]] = arith.addf %[[VAL_16]], %[[VAL_15]] : f32
// CHECK:             memref.store %[[VAL_17]], %[[VAL_9]][] : memref<f32>
// CHECK:           }
// CHECK:           scf.for %[[VAL_18:.*]] = %[[VAL_11]] to %[[VAL_1]] step %[[VAL_2]] {
// CHECK:             %[[VAL_19:.*]] = finch.access %[[VAL_8]], %[[VAL_18]] : f32
// CHECK:             %[[VAL_20:.*]] = finch.access %[[VAL_8]], %[[VAL_18]] : f32
// CHECK:             %[[VAL_21:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:             %[[VAL_22:.*]] = arith.mulf %[[VAL_19]], %[[VAL_20]] : f32
// CHECK:             %[[VAL_23:.*]] = arith.addf %[[VAL_22]], %[[VAL_21]] : f32
// CHECK:             memref.store %[[VAL_23]], %[[VAL_9]][] : memref<f32>
// CHECK:           }
// CHECK:           %[[VAL_24:.*]] = memref.load %[[VAL_9]][] : memref<f32>
// CHECK:           return %[[VAL_24]] : f32
// CHECK:         }
func.func @runsequence(%b0:index, %b1:index) -> f32{
  %i1 = arith.constant 1 : index
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 2.0 : f32
  %second_start1 = arith.constant 3 : index
  %second_start2 = arith.constant 6 : index

  %run1 = finch.run %f1 : (f32) -> (!finch.looplet)
  %run2 = finch.run %f2 : (f32) -> (!finch.looplet)
  %seq1 = finch.sequence %second_start1, %run1, %run2 : (index, !finch.looplet, !finch.looplet) -> (!finch.looplet)

  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %i1 {
    %unfurlseq = finch.access %seq1, %i : f32
    %unfurlrun = finch.access %run2, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.mulf %unfurlseq, %unfurlrun : f32
    %added = arith.addf %mul, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}
