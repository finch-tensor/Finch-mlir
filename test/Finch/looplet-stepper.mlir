// RUN: finch-opt %s --finch-looplet-stepper | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

// CHECK-LABEL:   func.func @test1(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_6:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_6]][] : memref<f32>
// CHECK:           %[[VAL_7:.*]]:2 = scf.while (%[[VAL_8:.*]] = %[[VAL_2]], %[[VAL_9:.*]] = %[[VAL_0]]) : (index, index) -> (index, index) {
// CHECK:             %[[VAL_10:.*]] = arith.cmpi ult, %[[VAL_9]], %[[VAL_1]] : index
// CHECK:             scf.condition(%[[VAL_10]]) %[[VAL_8]], %[[VAL_9]] : index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_11:.*]]: index, %[[VAL_12:.*]]: index):
// CHECK:             %[[VAL_13:.*]] = arith.minui %[[VAL_1]], %[[VAL_11]] : index
// CHECK:             %[[VAL_14:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:             scf.for %[[VAL_15:.*]] = %[[VAL_12]] to %[[VAL_13]] step %[[VAL_5]] {
// CHECK:               %[[VAL_16:.*]] = finch.access %[[VAL_14]], %[[VAL_15]] : f32
// CHECK:               %[[VAL_17:.*]] = memref.load %[[VAL_6]][] : memref<f32>
// CHECK:               %[[VAL_18:.*]] = arith.addf %[[VAL_16]], %[[VAL_17]] : f32
// CHECK:               memref.store %[[VAL_18]], %[[VAL_6]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_19:.*]] = arith.cmpi eq, %[[VAL_11]], %[[VAL_13]] : index
// CHECK:             %[[VAL_20:.*]] = scf.if %[[VAL_19]] -> (index) {
// CHECK:               %[[VAL_21:.*]] = arith.addi %[[VAL_11]], %[[VAL_5]] : index
// CHECK:               scf.yield %[[VAL_21]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_11]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_20]], %[[VAL_13]] : index, index
// CHECK:           }
// CHECK:           %[[VAL_22:.*]] = memref.load %[[VAL_6]][] : memref<f32>
// CHECK:           return %[[VAL_22]] : f32
// CHECK:         }
func.func @test1(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %c1 = arith.constant 1 : index

  %step = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f1 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }
  
  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurl = finch.access %step, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %added = arith.addf %unfurl, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}

// CHECK-LABEL:   func.func @test2(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 6.000000e+00 : f32
// CHECK:           %[[VAL_6:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_7:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_7]][] : memref<f32>
// CHECK:           %[[VAL_8:.*]]:3 = scf.while (%[[VAL_9:.*]] = %[[VAL_2]], %[[VAL_10:.*]] = %[[VAL_2]], %[[VAL_11:.*]] = %[[VAL_0]]) : (index, index, index) -> (index, index, index) {
// CHECK:             %[[VAL_12:.*]] = arith.cmpi ult, %[[VAL_11]], %[[VAL_1]] : index
// CHECK:             scf.condition(%[[VAL_12]]) %[[VAL_9]], %[[VAL_10]], %[[VAL_11]] : index, index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_13:.*]]: index, %[[VAL_14:.*]]: index, %[[VAL_15:.*]]: index):
// CHECK:             %[[VAL_16:.*]] = arith.minui %[[VAL_1]], %[[VAL_13]] : index
// CHECK:             %[[VAL_17:.*]] = arith.minui %[[VAL_16]], %[[VAL_14]] : index
// CHECK:             %[[VAL_18:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_19:.*]] = finch.run %[[VAL_5]] : (f32) -> (!finch.looplet)
// CHECK:             scf.for %[[VAL_20:.*]] = %[[VAL_15]] to %[[VAL_17]] step %[[VAL_6]] {
// CHECK:               %[[VAL_21:.*]] = finch.access %[[VAL_18]], %[[VAL_20]] : f32
// CHECK:               %[[VAL_22:.*]] = finch.access %[[VAL_19]], %[[VAL_20]] : f32
// CHECK:               %[[VAL_23:.*]] = memref.load %[[VAL_7]][] : memref<f32>
// CHECK:               %[[VAL_24:.*]] = arith.addf %[[VAL_21]], %[[VAL_22]] : f32
// CHECK:               %[[VAL_25:.*]] = arith.addf %[[VAL_24]], %[[VAL_23]] : f32
// CHECK:               memref.store %[[VAL_25]], %[[VAL_7]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_26:.*]] = arith.cmpi eq, %[[VAL_13]], %[[VAL_17]] : index
// CHECK:             %[[VAL_27:.*]] = scf.if %[[VAL_26]] -> (index) {
// CHECK:               %[[VAL_28:.*]] = arith.addi %[[VAL_13]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_28]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_13]] : index
// CHECK:             }
// CHECK:             %[[VAL_29:.*]] = arith.cmpi eq, %[[VAL_14]], %[[VAL_17]] : index
// CHECK:             %[[VAL_30:.*]] = scf.if %[[VAL_29]] -> (index) {
// CHECK:               %[[VAL_31:.*]] = arith.addi %[[VAL_14]], %[[VAL_6]] : index
// CHECK:               scf.yield %[[VAL_31]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_14]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_27]], %[[VAL_30]], %[[VAL_17]] : index, index, index
// CHECK:           }
// CHECK:           %[[VAL_32:.*]] = memref.load %[[VAL_7]][] : memref<f32>
// CHECK:           return %[[VAL_32]] : f32
// CHECK:         }
func.func @test2(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 6.0 : f32
  %c1 = arith.constant 1 : index

  %step1 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f1 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }

  %step2 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f2 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }

  
  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurl1 = finch.access %step1, %i : f32
    %unfurl2 = finch.access %step2, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.addf %unfurl1, %unfurl2 : f32
    %added = arith.addf %mul, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}

// CHECK-LABEL:   func.func @test3(
// CHECK-SAME:                     %[[VAL_0:.*]]: index,
// CHECK-SAME:                     %[[VAL_1:.*]]: index) -> f32 {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0.000000e+00 : f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 4.000000e+00 : f32
// CHECK:           %[[VAL_5:.*]] = arith.constant 6.000000e+00 : f32
// CHECK:           %[[VAL_6:.*]] = arith.constant 8.000000e+00 : f32
// CHECK:           %[[VAL_7:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_8:.*]] = memref.alloc() : memref<f32>
// CHECK:           memref.store %[[VAL_3]], %[[VAL_8]][] : memref<f32>
// CHECK:           %[[VAL_9:.*]]:4 = scf.while (%[[VAL_10:.*]] = %[[VAL_2]], %[[VAL_11:.*]] = %[[VAL_2]], %[[VAL_12:.*]] = %[[VAL_2]], %[[VAL_13:.*]] = %[[VAL_0]]) : (index, index, index, index) -> (index, index, index, index) {
// CHECK:             %[[VAL_14:.*]] = arith.cmpi ult, %[[VAL_13]], %[[VAL_1]] : index
// CHECK:             scf.condition(%[[VAL_14]]) %[[VAL_10]], %[[VAL_11]], %[[VAL_12]], %[[VAL_13]] : index, index, index, index
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_15:.*]]: index, %[[VAL_16:.*]]: index, %[[VAL_17:.*]]: index, %[[VAL_18:.*]]: index):
// CHECK:             %[[VAL_19:.*]] = arith.minui %[[VAL_1]], %[[VAL_15]] : index
// CHECK:             %[[VAL_20:.*]] = arith.minui %[[VAL_19]], %[[VAL_16]] : index
// CHECK:             %[[VAL_21:.*]] = arith.minui %[[VAL_20]], %[[VAL_17]] : index
// CHECK:             %[[VAL_22:.*]] = finch.run %[[VAL_4]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_23:.*]] = finch.run %[[VAL_5]] : (f32) -> (!finch.looplet)
// CHECK:             %[[VAL_24:.*]] = finch.run %[[VAL_6]] : (f32) -> (!finch.looplet)
// CHECK:             scf.for %[[VAL_25:.*]] = %[[VAL_18]] to %[[VAL_21]] step %[[VAL_7]] {
// CHECK:               %[[VAL_26:.*]] = finch.access %[[VAL_22]], %[[VAL_25]] : f32
// CHECK:               %[[VAL_27:.*]] = finch.access %[[VAL_23]], %[[VAL_25]] : f32
// CHECK:               %[[VAL_28:.*]] = finch.access %[[VAL_24]], %[[VAL_25]] : f32
// CHECK:               %[[VAL_29:.*]] = memref.load %[[VAL_8]][] : memref<f32>
// CHECK:               %[[VAL_30:.*]] = arith.mulf %[[VAL_26]], %[[VAL_27]] : f32
// CHECK:               %[[VAL_31:.*]] = arith.mulf %[[VAL_30]], %[[VAL_28]] : f32
// CHECK:               %[[VAL_32:.*]] = arith.addf %[[VAL_31]], %[[VAL_29]] : f32
// CHECK:               memref.store %[[VAL_32]], %[[VAL_8]][] : memref<f32>
// CHECK:             }
// CHECK:             %[[VAL_33:.*]] = arith.cmpi eq, %[[VAL_15]], %[[VAL_21]] : index
// CHECK:             %[[VAL_34:.*]] = scf.if %[[VAL_33]] -> (index) {
// CHECK:               %[[VAL_35:.*]] = arith.addi %[[VAL_15]], %[[VAL_7]] : index
// CHECK:               scf.yield %[[VAL_35]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_15]] : index
// CHECK:             }
// CHECK:             %[[VAL_36:.*]] = arith.cmpi eq, %[[VAL_16]], %[[VAL_21]] : index
// CHECK:             %[[VAL_37:.*]] = scf.if %[[VAL_36]] -> (index) {
// CHECK:               %[[VAL_38:.*]] = arith.addi %[[VAL_16]], %[[VAL_7]] : index
// CHECK:               scf.yield %[[VAL_38]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_16]] : index
// CHECK:             }
// CHECK:             %[[VAL_39:.*]] = arith.cmpi eq, %[[VAL_17]], %[[VAL_21]] : index
// CHECK:             %[[VAL_40:.*]] = scf.if %[[VAL_39]] -> (index) {
// CHECK:               %[[VAL_41:.*]] = arith.addi %[[VAL_17]], %[[VAL_7]] : index
// CHECK:               scf.yield %[[VAL_41]] : index
// CHECK:             } else {
// CHECK:               scf.yield %[[VAL_17]] : index
// CHECK:             }
// CHECK:             scf.yield %[[VAL_34]], %[[VAL_37]], %[[VAL_40]], %[[VAL_21]] : index, index, index, index
// CHECK:           }
// CHECK:           %[[VAL_42:.*]] = memref.load %[[VAL_8]][] : memref<f32>
// CHECK:           return %[[VAL_42]] : f32
// CHECK:         }
func.func @test3(%b0:index, %b1:index) -> f32{
  %f0 = arith.constant 0.0 : f32
  %f1 = arith.constant 4.0 : f32
  %f2 = arith.constant 6.0 : f32
  %f3 = arith.constant 8.0 : f32
  %c1 = arith.constant 1 : index

  %step1 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f1 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }

  %step2 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f2 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }

  %step3 = finch.stepper
      seek={
        ^bb0(%idx : index):
          %firstpos = arith.constant 0 : index 
          finch.return %firstpos : index
      }
      stop={
        ^bb(%pos : index):
          finch.return %pos : index
      }
      body={
        ^bb(%pos : index):
          %run = finch.run %f3 : (f32) -> (!finch.looplet)
          finch.return %run : !finch.looplet
      }
      next={
        ^bb0(%pos : index):
          %nextpos = arith.addi %pos, %c1 : index
          finch.return %nextpos : index
      }


  
  %sum = memref.alloc() : memref<f32>
  memref.store %f0, %sum[] : memref<f32>
  
  scf.for %i = %b0 to %b1 step %c1 {
    %unfurl1 = finch.access %step1, %i : f32
    %unfurl2 = finch.access %step2, %i : f32
    %unfurl3 = finch.access %step3, %i : f32
    
    %load = memref.load %sum[] : memref<f32>
    %mul = arith.mulf %unfurl1, %unfurl2 : f32
    %mul2 = arith.mulf %mul, %unfurl3 : f32
    %added = arith.addf %mul2, %load : f32
    memref.store %added, %sum[] : memref<f32>
  }
  
  %result = memref.load %sum[] : memref<f32>
  return %result : f32
}
